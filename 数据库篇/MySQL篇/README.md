## Mysql篇

#### 一、	数据库的事务，四种隔离机制，以及产生的问题？
##### 事务以及其属性：<br>
（1）、**原子性**：事务是SQL语句的基本逻辑运行单元，其对数据的修改，要么全部执行，要么全部不执行。（要么都发生，要么都不发生。）<br>
（2）、**一致性**：事务从一个状态改变到另外一个状态，事务开始和完成时，数据必须保持一致状态。（所有相关的数据规则都应用于事务的修改，来保持数据的完整性；）<br>
（3）、**隔离性**：数据库提供一定的隔离机制（事物之间互不干扰）。（保证事务在不受外部并发的影响下能独立执行。）<br>
（4）、**持久性**：事务完成后，它对数据的修改是永久性的。<br>

### 常用的mysql引擎有哪些? 各引擎间有什么区别?
**常用的引擎是：Innodb和Myiasm这两种引擎**
#### innodb：
提供了对事务的ACID操作，还提供了行级锁和外键约束，，他的优势就是处理大量数据，在msql启动的时候，首先会建立一个缓存池，主要是缓存数据和索引，但是操作大规模的数据查找时很慢，所以建议当需要数据库的事务操作时，使用这个，还有就是在写的时候不会锁定全表，所以在大规模并发操作的时候会提高效率；

#### Myiasm：
 这个是默认的引擎，不提供事务和行级锁和外键约束，当在insert和update时会锁定全表，所以在执行写操作对的时候效率会很慢， 
和innodb不同的是，myiasm保留了行数，所以在执行`select count（*） from `的时候会很快，不需要扫描全表，当我们执行的读操作多于写操作的时候，并且不需要事务的支持，我们可以使用myisam这个引擎。
#### 各引擎间有什么区别?
- 一、InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM就不可以了；

- 二、MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；

- 三、InnoDB 支持外键，MyISAM 不支持；

- 四、MyISAM 是默认引擎，InnoDB 需要指定；

- 五、InnoDB 不支持 FULLTEXT 类型的索引；
- 六、InnoDB 中不保存表的行数，如 select count(*) from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count(*)语句包含 where 条件时 MyISAM 也需要扫描整个表；
- 七、对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；
- 八、清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；
#### 数据库索引的三种常用方式？
https://blog.csdn.net/qq_32483145/article/details/80191323
【磁盘I/O操作次数等于索引树的高度】：相比较于IO操作，内存的比较耗时可以忽略不计。所以：**IO次数越少，查找性能越优。**
#### B树：
- 1.根结点至少有两个子女。<br>
- 2.每个中间节点都包含**k-1个元素和k个孩子**，其中 m/2 <= k <= m;<br>
- 3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m;<br>
- 4.所有的叶子结点都位于同一层。<br>
- 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br>
#### 用途：
主要用于**文件系统以及部分数据库索引**（比如：MongoDB菲关系型数据库）
#### B+ 树：
- 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>
- 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（每一个叶子节点都带有指向下一节点的指针）。<br>
- 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。（最大元素在根节点）<br>
#### 【总结】：优于B树的几点：
- 1、【IO次数更少】:单一节点存储更多的元素，相同数据量时，比B树“矮胖”（查询时，IO操作少，性能更优）<br>
- 2、【查询性能稳定】: B+ 树每一次查找都到叶子节点，性能稳定；B树最好情况为只查根节点，最坏为查到叶子节点。<br>
- 3、【范围查询简便】 :叶子节点形成有序链表，B+树范围查询时只需在链表上遍历即可。<br>
	
#### 数据库联接操作，左连接，右链接，全链接的操作以及区别，问了数据库的三大范式的理解。
#### 	乐观锁和悲观锁
- **悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- **乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

### MySQL的innodb引擎是如何实现MVCC的
>innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现：

- select：满足以下两个条件innodb会返回该行数据：
该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
- **insert**：将新插入的行的创建版本号设置为当前系统的版本号。
- **delete**：将要删除的行的删除版本号设置为当前系统的版本号。
- **update**：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
**由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。**

[参考：MVCC浅析]http://blog.csdn.net/chosen0ne/article/details/18093187

### 视图的作用，视图可以更改么？
视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询;不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据;视图创建后，可以使用与表相同的方式利用它们。<BR>

视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。
```
创建视图： create view xxx as xxxxxx
```
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新;但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。

#### 主键 超键 候选键 外键 介绍一下？
- **主键**：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值(Null).

- **超键**：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

- **候选键**：是最小超键，即没有冗余元素的超键。

- **外键**：在一个表中存在的另一个表的主键称此表的外键。
### 索引的工作原理及其种类
数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用**B树 以及 B+树**。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间

